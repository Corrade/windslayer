todo
    pre-match
    testing with multiple players
    respawning
    spectator cam

    refactor hit stun and blcok stun to different location probably


gamemodes
    deathmatch. team with most KO's at the end of the time wins. timer. dying -> spec -> respawn

spectator mode
    spec mode: click on player portrait to spec. keypress to cycle through players. dead players including oneself can be viewed; just goes to their gravestone. click on something to enter freecam, which is the default cam if there are no players or something

    spectator mode implemented by client? except ofc ignore all input from spectators
    should despawn player hitbox so they aren't involved in collision checks etc

game flow
    pre-match
        join team 1 or 2
        join spec
        leave arena
        setup arena (host only)
            max players (moves any excess players who've already joined a team into spec)
            gamemode (implement later)
                kill limit
                time limit
                respawn time
        start game (must have at least one player on each team)

    combat
        upon death, respawn after a while. whilst waiting move into spec

    end condition
        freeze all players, announce winner, force show scoreboard, transition to pre-match

ui
    main menu
    server browser
        host server interface
    hud
        health and mana
        skills
        chatbox
    skill menu
    tab scoreboard (join teams, leave arena)
    character menu (skills and stats; drag skills to hud skills)
    settings menu
        keybinding

other features
    multiple gamemodes
    kick as host
    move another player to spec as host
    votekick




In order to prevent resource leaks, it is important to unsubscribe from events before you dispose of a subscriber object.


totally invincible during hit stun?



https://github.com/MFatihMAR/Game-Networking-Resources



elementalist https://www.youtube.com/watch?v=4JMx2fWfuD8
novice https://www.youtube.com/watch?v=iY_swqviRk0
royalz (ws2) https://www.youtube.com/watch?v=W3ci2qglLWo
elementalist (ws2) https://www.youtube.com/watch?v=kU6irPevMfY
rogue https://www.youtube.com/watch?v=y-OZhKhDRC0
monk https://www.youtube.com/watch?v=7esWbQEzSFA
shaolin/counter https://www.youtube.com/watch?v=YG4tUOohzkk





blocking perhaps deviates from the original game: when you're hit whilst blocking, you enter block stun, which interrupts your block. in windslayer it seems like you didn't get stunned at all.

landing on the ground whilst doing an air move: the air move continues on the ground

attack used: startup -> active -> recovery
                               -> OR INSTEAD attacker stun (if you are airborne, hit an enemy and they don't block it. such airborne hits are only possible if you're using a light/strong attack)

hit by enemy -> block stun (if blocking)
             -> OR INSTEAD hit stun

attacker stun and hit stun: suspended (preserve velocity) + silenced + disarmed, also brief invincibility
    hit stun behaves as above when applied by an ability used from the ground https://youtu.be/4JMx2fWfuD8?t=220
    attacker stun behaves as above when applied by an airborne strong attack https://youtu.be/YG4tUOohzkk?t=43

duration
    FOR THE SAME MOVE
    block stun < attacker stun < hit stun
    recovery ~= attacker stun (for an equivalent attack when performed on the ground vs airborne) (?)

if you're hit while in attacker stun (and possibly other stuns), you immediately go into the hit stun / block stun (well, you wouldn't be blocking if you're in attacker stun). this may actually be shorter than your current stun.



abilities https://docs.google.com/spreadsheets/d/1QUnXIzWVExO5JoW9OS_05YbLq0kzF8RGI3YQcIGdbmk/edit?usp=drive_web&ouid=108112850293498042381

oo https://docs.google.com/document/d/1tVc7g_WdPEFBj_nemLt3S26gVPeTTZRs0MWle653z_Q/edit
    often in pursuit of maximum flexibility (minimal immobility), you introduce needless complexity

    design smells
        - rigidity: change is difficult, often requiring multiple other changes to be made
        - fragility: a single change causes widespread breakage
        - immobility: the design is hard to reuse
        - viscosity
            - software viscosity: change is easier to implement through hacks rather than good practices
            - environment viscosity: development environment is slow and inefficient
        - opacity: difficult to understand
        - needless complexity: contains constructs that are not currently useful. usually a symptom of developers being too far ahead of requirements
        - needless repetition
        - data clumps: different sections of code contain identical clumps of data, e.g. fields in many classes, parameters in many methods. consider consolidating these things into a new class and passing around larger objects, e.g. entire ‘classes’ rather than fields
        - refused bequest: when a subclass doesn’t use or must redefine something in the superclass. e.g. if an engineer class inherits an employee class that is mostly suitable but has sales quota fields and methods that the engineer never uses, one should consider moving that sales information to a salesperson subclass
        - switch statements. prefer polymorphism and consider the strategy pattern

    characteristics of good design
        - loose coupling: small chains of dependencies between modules
        - high cohesion: modules and classes are themed and internally unified by some goal

    design principles
        - apply design principles only in response to design smells, not just randomly
        - unconditionally conforming to a principle often leads to needless complexity
        - solid
            - single responsibility principle: a class should only have a single responsibility
            - open-closed principle: software entities should be open for extension but closed for modification
            - liskov substitution principle: subtypes must be substitutable for their base types. all of a superclass’ methods should make - sense in the context of a subclass
            - interface segregation principle: many client-specific interfaces are better than one general-purpose interface
            - dependency inversion principle: one should ‘depend upon abstractions, not concretions’
        - law of demeter/principle of least knowledge
            - classes should know about and interact with as few classes as possible
            - classes that are known/interacted with should be nearby
        - reduce long segments of code by extracting methods
            - identify legs where certain variables aren’t changed; they can be parameters to a new function
        - move methods so that they belong to the class of whose data they use the most
        - encapsulate to protect, e.g. setters and getters
        - program to an interface, not an implementation
        - separate concerns; divide and conquer
        - when implementing different variations of an entity, favour polymorphism/subclassing over conditional logic with variables
            - not suitable if you need to be able to change variations
            - not suitable if it’ll result in an overwhelming number of classes, particularly if there are multiple things being varied
        - favor composition over inheritance

    design patterns
        https://en.wikipedia.org/wiki/Software_design_pattern#Classification_and_list



PLAYER CONNECTIONS
    client connect
        server creates player manager
        client -> PlayerMetadataMsg -> server
        server -> PlayerMetadataMsg -> ALL (only now is the player truly connected - clients register the new player)
        (fill the client in on all the game happenings. lobby settings, win conditions state if applicable, teams of all players)

    client disconnect
        server -> DisconnectPlayerMsg -> ALL
        (remember to remove the player from all relevant data structures)

LOBBY AND TEAM
    lobby configuration
        client -> LobbySettingsMsg -> server (if the client is the host)
        server -> LobbySettingsMsg -> ALL

    game start
        client -> StartGameMsg -> server (if the client is the host)
        server spawns map, starts timer, spawns players
        server -> SpawnPlayerMsg -> ALL (for each player in a team)
        server -> StartGameMsg -> ALL

    game end
        server -> DespawnPlayerMsg -> ALL (for each player spawned)
        server -> EndGameMsg -> ALL

    team select
        client -> TeamDeclarationMsg -> server (id of the player in the message must match the id of the client)
        server -> TeamDeclarationMsg -> ALL
        server swaps the player's team

        if in-game, additionally sandwich this process between:
            server -> DespawnPlayerMsg -> ALL
            server -> SpawnPlayerMsg -> ALL

    win conditions update (team kill count change, time left change)
        TODO: server -> WinConditionsStateMsg -> ALL

GAMEPLAY
    client -> PlayerCombatInputMsg -> server
    server -> player movement, player status, player used ability, player got a kill



DESIGN DILEMMA
essentially a question of "how dumb is the client"

one option is to communicate at a rather high level. e.g. player 2 did strong attack. let the client calculate health and damage on their own - essentially a state machine approach.
PROBLEM: what if a packet drops? and we don't want to send these attacks via TCP because of speed concerns

but i worry the atlernative will involve sending too much info

suppose player 2 uses the attack "fire arrow" and it hits player 1. throughout the course of this interaction, the server would've have to communicate:
- fire arrow ability used (tcp)

- player 2 is temporarily stunned while they're casting the ability

- fire arrow projectile created (NO NEED: FOLLOWS FROM ABILITY USAGE)

- position of the fire arrow projectile (NO NEED: THIS SHOULD BE DETERMINISTIC)
    NO
    projectiles should have deterministic positions
    homing projectiles? not sure

- player 1 damage taken
    YES - SEND
    the client could calculate this themselves by doing its own hitbox checks. BUT what if the client has an outdated view of the opponents? then they could reigster damage taken and be wrong. so the server needs to communicate it to be sure

- player 1 is temporarily stunned from taking damage
    YES - PIGGYBACK
    stun duration could be piggybacked off of the damage taken msg

- fire arrow projectile destroyed (because it hit player 1, let's say)








networking
    https://en.wikipedia.org/wiki/Netcode
    https://en.wikipedia.org/wiki/Lag#Solutions_and_lag_compensation

    https://www.gabrielgambetta.com/client-server-game-architecture.html

    "Source engine server employs techniques such as data compression and lag compensation which are invisible to the client. The client then performs prediction and interpolation to further improve the experience."

    client side prediction uses the same code that the server uses for movement checking/logic


    always send inputs, not position
    not sending the data at all until the player is supposed to see it is the only sure way to keep it secret


    During each tick, the server processes incoming user commands, runs a physical simulation step, checks the game rules, and updates all object states.



@SandwichBop I use Vultr.com to host most of my servers, $5 USD/month for a vps, 1 GB RAM, 1 CPU, heaps of bandwidth
DigitalOcean's a good contender










DATA FUNDAMENTALS
    clients run at a certain at a tickrate
    clients manage a ring buffer of player inputs indexed by tick. each tick will be a list of inputs that were entered during that tick. a ring buffer is used to store data from previous frames as well as the current one. this way, if there is packet loss, other nodes can reconstruct a client's input history

(DETERMINISTIC) LOCKSTEP
    https://ki.infil.net/w02-netcode-p4.html
    https://www.ggpo.net/
    https://gafferongames.com/post/deterministic_lockstep/

    lockstep is where you transmit purely input (keypresses, ability usage, etc.) as opposed to state (position, orientation, velocity, etc.). all clients simulate the game logic based on the input.
    the size of the bandwidth is now proportional to the quantity of inputs, not the amount of objects or data or anything! usually very efficient
    this relies on the system being deterministic; same input -> same state. this is actually hugely NOT characteristic of physics simulations due to differences in os's, compilers, etc.

    NAIVE
        tick N renders once the input of all players for tick N has arrived
        therefore tick N renders at the speed of the slowest connection

        bad. things are always blocking for input since the other player is always behind

    DELAY-BASED
        tick N attempts to render after X ticks
        we assume that during this interval of X ticks, all players' inputs would've been received. (this creates a PLAYOUT DELAY BUFFER, which is similar to what video streaming sites do. they pre-load the content so it can be played back) we set X based on the latency of the players
        if all players' inputs haven't been received after X ticks, then the game halts until the inputs come in. this period of freezing is ideally imperceptible, but it has the potential to be long and incredibly jarring when connections are unstable

    ROLLBACK
        tick N renders immediately. the client's input is available, played immediately and transmitted. the remote player's input is assumed to be their input in tick N-1 (PREDICTION). the client saves the game state at tick N
        later in tick N+J, the remote player's input for tick N arrives. if that input differs from what we predicted (DE-SYNC), we re-simulate from tick N, the point of divergence, to the current tick: the client, separately from their current game state and without rendering anything, loads the saved game state at tick N (ROLLBACK) and applies the real input of the remote player. this produces a new version of the game state at tick N. the game re-calculates the game states of ticks N+1...N+J starting from the correct tick N game state and renders the result as tick N+J

        + client inputs are immediately played
        + prediction technique is simple but effective, meaning there isn't a need to re-adjust a lot of the time
        + mechanism only intervenes if a delay has occured
        - a rollback will always occur whenever input changes (as the continuation of the previous input will be incorrect)

        deterministic behaviour + capacity for rapid saving and loading of game states = rollback viable (nothing to do with genre in and of itself)

        saving and loading game states in the background requires that game states are serialisable
        calculating an additional game state in the background requires that gameplay is decoupled from rendering
        rollback may result in cancelling or reviving things such as sound effects and particles that were wrongly initiated/destroyed, which demands technical consideration
        both clients should be processing the same tick N at the same time (DE-SYNC) (see article for an example of what happens if this isn't adhered to). this is usually solved by delaying the ahead player by a few frames every now and then

        "Maybe the first point to talk about would be the startup of moves. Because rollbacks happen only around your opponent’s button presses, it means when a rollback occurs, it always cuts off some part of the startup. This means having moves with slower startup makes it easier to hide rollbacks."

    ROLLBACK + DELAY
        delay rendering tick N for X ticks as you would for a delay-based system. but when players' inputs haven't arrived after X ticks, switch to a rollback method of handling tick N
        X is constant

        + prevents rollbacks from always occuring whenever input changes. if the input arrives within X ticks then it's fine

    ROLLBACK WITH AN AUTHORITATIVE SERVER
        https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html
        https://medium.com/@geretti/netcode-series-part-4-projectiles-96427ac53633
        https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking
        
        tick N renders immediately. the client's input is available, played immediately (CLIENT-SIDE INPUT PREDICTION) and transmitted
        2 mutually-compatible options for remote player movement:
            - INTERPOLATION BACK TIME: the remote players are moving in accordance with tick N-I as provided by the server. other players are shown as they were in the past. this is comparable to delay-based netcode but instead of taking a while for client input to appear, it takes a while for opponent's input to appear, simply to avoid a naive solution of waiting for all inputs
            - INPUT EXTRAPOLATION: we predict where others are going like rollback. bad for physics simulations
        the client saves only THEIR player state at tick N (hereafter 'player state' refers to the client's individual state)
        later in tick N+J, the server's player state for tick N arrives. if that differs from what we communicated (DE-SYNC), we re-simulate from tick N, the point of divergence, to the current tick: the client, separately from their current player state and without rendering anything, loads the saved player state at tick N-1 (ROLLBACK), applies the server's authoritative version of tick N, and replays the client's input from ticks N+1..N+J. this produces a new version of the player state at the current tick N+J. this is maintained in parallel with the rendered player state as it is gradually interpolated into the rendered state

SNAPSHOTS
    general outline https://medium.com/@geretti/netcode-series-part-4-projectiles-96427ac53633
    implementation https://fabiensanglard.net/quake3/network.php
    high-level description https://gafferongames.com/post/snapshot_interpolation/

    a snapshot model focuses on transmitting state rather than input. the server performs most of the simulation and the clients just send their input to the server.
    the size of the bandwidth is proportional to the quantity of objects or data. lots more than lockstep

    the server sends snapshots and the client interpolates between them



LOCKSTEP VS SNAPSHOTS
    LOCKSTEP
        can be peer-to-peer, which is generally faster in the case of two clients
        must be deterministic
        must be able to save, load and simulate game states rapidly on clients
        true synchronisation (players see the same events on the screen) when delay-based elements are used
            in cases where network is nice and all packets are sent within the delay, no lag compensation is ever necessary. there are only issues when delays are affecting just one party, in which case the unaffected party is favoured since they get to act in realtime whereas their opponent is confused by faulty predictions and janky rollbacks. however this is rare since usually both players' inputs will be delayed

    SNAPSHOTS
        must be client-server as peers cannot be trusted to send correct states
        higher bandwidth
        no true synchronisation
            even in cases where the network is perfectly stable and a nice ping, there is always the issue of lag compensation. it's not clear whether to bias the attacker (who shot a past-version of the victim) or the victim (who evaded the attacker ages ago)

    anyway, hybrid designs are possible. lockstep for the client's own inputs and then snapshots for remote players?







communicate the data if there is no way for the player to know it?



ability calls
damage and kills
hitbox cleanup (for hitboxes with variable lifetimes - pierce count, projectiles)
status changes (especially with little statuses like casting)



/*
broadcast just the player client here

// Broadcast the new player to all existing players
using (Message msg = Message.Create(
    Tags.SpawnPlayer,
    new SpawnPlayerMsg(e.Client.ID)
)) {
    foreach (IClient client in m_XmlServer.Server.ClientManager.GetAllClients().Where(x => x != e.Client)) {
        client.SendMessage(msg, SendMode.Reliable);
    }
}

// Broadcast all players (including the new player itself) to the new player
using (DarkRiftWriter w = DarkRiftWriter.Create()) {
    foreach (GameObject p in m_PlayerManagers.Values) {
        PlayerConnectionManager c = p.GetComponent<PlayerConnectionManager>();
        w.Write(new SpawnPlayerMsg(c.ClientID));
    }

    using (Message msg = Message.Create(Tags.SpawnPlayer, w)) {
        e.Client.SendMessage(msg, SendMode.Reliable);
    }
}
*/



            using (Message message = e.GetMessage())
            using (DarkRiftReader reader = message.GetReader()) {
                // Multiple players are combined into one message, so loop
                while (reader.Position < reader.Length) {
                    SpawnPlayerMsg msg = reader.ReadSerializable<SpawnPlayerMsg>();

                    c_PlayerConnectionManager player;

                    if (msg.ClientID == Client.ID) {
                        player = Instantiate(ThisPlayerPrefab, Vector3.zero, Quaternion.identity);
                        Cam.Target = player.transform;
                    } else {
                        player = Instantiate(OtherPlayerPrefab, Vector3.zero, Quaternion.identity);
                    }

                    player.Initialise(Client);

                    // m_Players.Add(msg.ClientID, player);
                }
            }