todo
    actually fix movement
    camera

    ability system
    light attack
    heavy attack
    guard and blocking
    dash
    hook double jump into ability system





server browser
connecting to server
game end conditions
scoreboard

menus
    top
        pvp interface
        skills
        settings
    mid
        character info (name, class, guild, hp/mp, exp, pvp, attack, defence, other stats)
        equipment
        inventory
    low
        quests
        map
        social (friends, guild)

ability manager
settings manager
record manager (name, class, rank, pvp stats)
social manager (friends, guild)
item manager (equipment, inventory)
quest manager
map manager (position in map, seen areas, etc.)

networking
    https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking
    https://www.darkriftnetworking.com/DarkRift2/Docs/2.10.0/getting_started/index.html
    https://en.wikipedia.org/wiki/Netcode
    https://en.wikipedia.org/wiki/Lag#Solutions_and_lag_compensation

    https://www.gabrielgambetta.com/client-server-game-architecture.html

    "Source engine server employs techniques such as data compression and lag compensation which are invisible to the client. The client then performs prediction and interpolation to further improve the experience."

    client side prediction uses the same code that the server uses for movement checking/logic


    always send inputs, not position
    not sending the data at all until the player is supposed to see it is the only sure way to keep it secret


keys
    toggle chat
    move left
    move right
    jump
    crouch
    settings
    quests
    map
    social tab
    inventory
    equipment
    character sheet
    skills
    pvp menu
    pick up
    interact
    ABILITY KEYBINDS





prefer this to defining hitbox subclasses to centralise the palatably low amount of code associated with a single ability

gotta have an easy way to adjust stats and apply statuses on a timer
removing these statuses shouldn't be the responsibility of the ability, but rather of the inflicted person or of the debuff/buff itself

dot (tick speed, damage per tick)
apply damage (damage type)

any attack : ability
    colliders
    ability script
        public collider(s)
        private hitbox class(es)
            each one is passed in a collider, curve, speed, maxduration, pierce, Hit, isTarget, parent, etc.
        in OnActiveBegin(), those hitboxes are instantiated
        definitionsof Hit and isTarget (usually only one of each)

during startup and recovery, the player may not provide any movement or ability input, but they're still affected by their existing momentum (sliding and gravity)









hold jump to jump further. note that the windslayer max jump height is super high


attack used: startup -> active -> recovery (or attacker stun)
enemy hit -> block stun or hit stun
block stun < attacker stun < hit stun
    attacker stun: if you hit a strong attack in the air that's not blocked, you are stunned, but of course for a shorter time than your target's hit stun. accordingly, hit stun is a lot longer than usual. this mechanic slows down combat.

if you're hit while in attacker stun (and possibly other stuns), you immediately go into the hit stun / block stun (well, you wouldn't be blocking if you're in attacker stun). this may actually be shorter than your current stun.

https://www.youtube.com/watch?v=HOZqk6jDPIc
    grounded strong: slow
    air strong: fast and has attacker stun

    attacker stun prevents ALL movement
    hit stun prevents ALL movement, at least for strong attacks

air strong attack (can flip directions) interrupt if hit ground




abilities https://docs.google.com/spreadsheets/d/1QUnXIzWVExO5JoW9OS_05YbLq0kzF8RGI3YQcIGdbmk/edit?usp=drive_web&ouid=108112850293498042381

mage v warrior https://www.youtube.com/watch?v=rKdISL55qhg
team fight https://www.youtube.com/watch?v=W3ci2qglLWo
counter vs shaolin https://www.youtube.com/watch?v=YG4tUOohzkk
various 1v1s https://www.youtube.com/watch?v=RMUTTRkjOP4
    1:54: block stun < attacker stun < hit stun.

oo https://docs.google.com/document/d/1tVc7g_WdPEFBj_nemLt3S26gVPeTTZRs0MWle653z_Q/edit
    often in pursuit of maximum flexibility (minimal immobility), you introduce needless complexity

    design smells
        - rigidity: change is difficult, often requiring multiple other changes to be made
        - fragility: a single change causes widespread breakage
        - immobility: the design is hard to reuse
        - viscosity
            - software viscosity: change is easier to implement through hacks rather than good practices
            - environment viscosity: development environment is slow and inefficient
        - opacity: difficult to understand
        - needless complexity: contains constructs that are not currently useful. usually a symptom of developers being too far ahead of requirements
        - needless repetition
        - data clumps: different sections of code contain identical clumps of data, e.g. fields in many classes, parameters in many methods. consider consolidating these things into a new class and passing around larger objects, e.g. entire ‘classes’ rather than fields
        - refused bequest: when a subclass doesn’t use or must redefine something in the superclass. consider revising the inheritance and pushing fields and methods from the superclass into subclasses. e.g. if an engineer class inherits an employee class that is mostly suitable but has sales quota fields and methods that the engineer never uses, one should consider moving that sales information to a salesperson subclass
        - switch statements. prefer polymorphism and consider the strategy pattern

    characteristics of good design
        - loose coupling: small chains of dependencies between modules
        - high cohesion: modules and classes are themed and internally unified by some goal

    design principles
        - apply design principles only in response to design smells, not just randomly
        - unconditionally conforming to a principle often leads to needless complexity
        - solid
            - single responsibility principle: a class should only have a single responsibility
            - open-closed principle: software entities should be open for extension but closed for modification
            - liskov substitution principle: subtypes must be substitutable for their base types. all of a superclass’ methods should make - sense in the context of a subclass
            - interface segregation principle: many client-specific interfaces are better than one general-purpose interface
            - dependency inversion principle: one should ‘depend upon abstractions, not concretions’
        - law of demeter/principle of least knowledge
            - classes should know about and interact with as few classes as possible
            - classes that are known/interacted with should be nearby
        - reduce long segments of code by extracting methods
            - identify legs where certain variables aren’t changed; they can be parameters to a new function
        - move methods so that they belong to the class of whose data they use the most
        - encapsulate to protect, e.g. setters and getters
        - program to an interface, not an implementation
        - when implementing different variations of an entity, favour polymorphism/subclassing over conditional logic with variables
            - not suitable if you need to be able to change variations
            - not suitable if it’ll result in an overwhelming number of classes, particularly if there are multiple things being varied
        - favor composition over inheritance

c#
    public: access is not restricted.
    protected: access is limited to the containing class or types derived from the containing class.
    internal: access is limited to the current assembly.
    protected internal: access is limited to the current assembly or types derived from the containing class.
    private: access is limited to the containing type.
    private protected: access is limited to the containing class or types derived from the containing class within the current assembly. available since c# 7.2.


    virtual vs abstract
        an abstract function cannot have functionality. you're basically saying, any child class must give their own version of this method, however it's too general to even try to implement in the parent class.

        a virtual function, is basically saying look, here's the functionality that may or may not be good enough for the child class. so if it is good enough, use this method, if not, then override me, and provide your own functionality. and remember you can reference this the parent's implemention from the child using the base keyword, so there's still a point to specifying a virtual function that's always gonna be overriden.

    singleton vs static stuff
        A singleton allows access to a single created instance - that instance (or rather, a reference to that instance) can be passed as a parameter to other methods, and treated as a normal object.

        A static class allows only static methods.

        Plus static variables can't be exposed to the editor.

    design patterns
        https://en.wikipedia.org/wiki/Software_design_pattern#Classification_and_list

